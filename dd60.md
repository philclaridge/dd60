# DD60 Display Specifications and Research

This document accumulates detailed information about the DD60 display system for the CDC6600 console.

## Table of Contents
1. [Overview](#overview)
2. [Historical Context](#historical-context)
3. [Technical Specifications](#technical-specifications)
4. [Observed Display Characteristics](#observed-display-characteristics)
5. [Modern Emulation Considerations](#modern-emulation-considerations)
6. [Research References](#research-references)
7. [Appendix: Modern CRT Emulation Analysis](#appendix-modern-crt-emulation-analysis)

## Overview

The DD60 was the display console for the CDC6600 supercomputer, featuring a vector-based CRT display system that was revolutionary for its time. The system was developed with Seymour Cray working alongside Jim Thornton, system architect and "hidden genius" of the 6600 [⁶](https://en.wikipedia.org/wiki/CDC_6600).

### Key Characteristics
- **True Vector Display**: Beam controlled as vector, not raster [¹](https://retrocomputing.stackexchange.com/questions/17115/cdc-6600-system-console)
- **Dual CRT System**: Two displays (later models used single CRT with switch) [¹](https://retrocomputing.stackexchange.com/questions/17115/cdc-6600-system-console)
- **Whimsical Handwritten Appearance**: Analog circuit response distorted angular stroke patterns [²](https://www.mail-archive.com/cctalk@classiccmp.org/msg36279.html)

## Historical Context

### Development Team
- **Design Authority**: According to Seymour Cray's foreword, "Mr. Thornton was personally responsible for most of the detailed design of the Control Data model 6600 system" [⁷](https://www.computerhistory.org/collections/catalog/102630394)
- **Performance Context**: The CDC 6600 outperformed IBM 7030 Stretch by factor of three, achieving up to 3 megaFLOPS (1964-1969) [⁶](https://en.wikipedia.org/wiki/CDC_6600)

### Notable Design Features
The DD60 display was part of Seymour Cray's innovative design for the CDC6600, representing cutting-edge display technology of the 1960s. Its distinctive character appearance resulted from bandwidth limitations in the analog signal chain, creating an unintentionally iconic visual style.

## Technical Specifications

### Hardware Components

#### CRT and Phosphor
- **CRT Model**: K2263-P31 manufactured by Fairchild Camera and Instrument Corporation [²](https://www.mail-archive.com/cctalk@classiccmp.org/msg36279.html)
- **Phosphor Type**: P31 - short persistence (<1ms), high brightness [⁴](https://pubmed.ncbi.nlm.nih.gov/9176941/)
- **Phosphor Decay**: P31 phosphor decays to 1.4% in 50ms at photopic luminance [⁴](https://pubmed.ncbi.nlm.nih.gov/9176941/)
- **Effective Decay**: 2ms when superimposed on dim background [⁴](https://pubmed.ncbi.nlm.nih.gov/9176941/)

#### Deflection System
- **Type**: Electrostatic deflection [²](https://www.mail-archive.com/cctalk@classiccmp.org/msg36279.html)
- **Deflection Amplifier**: 3CX100A5 UHF transmitter tubes with 2000V plate voltage [²](https://www.mail-archive.com/cctalk@classiccmp.org/msg36279.html)
- **Deflection Sensitivity**: Typical electrostatic CRTs require 160V/inch [⁵](https://labguysworld.com/ES_CRT_DEFLECTION.htm)
- **Beam Control**: On/off modulation with X/Y voltage-controlled positioning [¹](https://retrocomputing.stackexchange.com/questions/17115/cdc-6600-system-console)

#### Beam Intensity Control (Z-axis)
- **Note**: Electron beam on/off switching has separate low-pass filter characteristics from X/Y deflection
- **Expected Behavior**: Different bandwidth and rise/fall times than deflection system
- **Implementation Note**: To be characterized separately from deflection filters

#### Signal Processing
- **Display Controller**: 6602/6612 display controller generates waveforms via A/D circuits [³](https://classiccmp.org/pipermail/cctech/2018-June/032841.html)
- **Signal Path**: Analog differential signals from controller to DD60 via coax cables [³](https://classiccmp.org/pipermail/cctech/2018-June/032841.html)
- **Signal Chain Components**: Early 1960s transistors, tubes in final stages [³](https://classiccmp.org/pipermail/cctech/2018-June/032841.html)
- **I/O Processing**: Dedicated I/O processor reads XY coordinates from CPU memory [¹](https://retrocomputing.stackexchange.com/questions/17115/cdc-6600-system-console)

### Vector Character Generator

#### Coordinate System
- **Display Origin**: Bottom left at coordinates (0,0) [User specification]
- **D/A Resolution**: 9-bit digital-to-analog conversion [User specification]
- **Addressable Grid**: 512×512 nominal grid for CRT deflection (prior to analog effects) [User specification]
- **Character Grid**: 8×8 base grid for character design
- **Character Scaling**: Hardware supports small/medium/large/quadruple character sizes through analog circuits

#### Stroke Generation System
- **Digital Stroke Generator**: Each character composed of strokes with 0, 1, or 2 units of distance [¹](https://retrocomputing.stackexchange.com/questions/17115/cdc-6600-system-console)
- **Incremental Movement**: Characters drawn using relative positioning from end of prior stroke [¹](https://retrocomputing.stackexchange.com/questions/17115/cdc-6600-system-console)
- **Directional Steps**: One or two element step in X and/or Y per segment [²](https://www.mail-archive.com/cctalk@classiccmp.org/msg36279.html)
- **Stroke Pattern Design**: Angular and straight-lined patterns generated by controller [²](https://www.mail-archive.com/cctalk@classiccmp.org/msg36279.html)
- **Movement Encoding**: Each stroke segment encodes X displacement (-2, -1, 0, +1, +2), Y displacement (-2, -1, 0, +1, +2), and beam state (On/Off)

#### Character Decoding from CDC 6602 Vector ROM
Based on CDC 6600 Diagrams and Circuit Description pages 26-30, each character is encoded as a table with columns T, V1, V2, H1, H2, U:

**Decoding Algorithm:**
1. **Initial State Setup:**
   - Process first row (T=76) to establish starting position from origin (0,0)
   - Beam state: OFF
   - Horizontal direction flag: positive
   - Vertical direction flag: positive

2. **Movement Control Flags:**
   - **V1, V2 (Vertical):**
     - Both clear: No vertical movement
     - V1 only: Move 1 unit in current vertical direction
     - V2 only: Move 2 units in current vertical direction
     - Both set: No movement, toggle vertical direction flag for next move
   - **H1, H2 (Horizontal):** Same logic as V1/V2 for horizontal movement

3. **Beam Control:**
   - **U Flag:** When set, toggles beam state (OFF↔ON)

4. **Timing Sequence:**
   - First row labeled T=76 establishes character starting position
   - Subsequent rows labeled T=00 through T=25 (octal) define vector sequence
   - Each row represents one 100ns stroke segment

**Example Decoding (Letter 'C'):**
- T=76: V2=1, H2=1 → Move +2V, +2H → Start position: (2,2), Beam OFF
- T=00: V2=1, H2=1 → Move +2V, +2H → Position: (4,4), Beam OFF  
- T=01: V1=1, H2=1 → Move +1V, +2H → Position: (6,5), Beam OFF
- T=03: H1=1, H2=1, U=1 → Toggle H direction, Beam ON → Draw begins
- Continue sequence to trace complete 'C' character path

This encoding allows precise control of the vector drawing sequence while maintaining compact storage in ROM.

#### Timing Specifications
- **Stroke Segment Duration**: 100ns per segment
- **Clock Cycle**: 100ns per stroke segment [²](https://www.mail-archive.com/cctalk@classiccmp.org/msg36279.html)
- **Maximum Step Size**: 2 units (base scale) per segment
- **Maximum Stroke Speed**: 8 display units per 100ns (with 2 unit max step and 4x scaling for large) [³](https://classiccmp.org/pipermail/cctech/2018-June/032841.html)
- **Full Screen Movement**: 512 units traversed in approximately 3 microseconds [³](https://classiccmp.org/pipermail/cctech/2018-June/032841.html)
- **Character Base Position Step**: ~3μs for full screen (512 units) movement [³](https://classiccmp.org/pipermail/cctech/2018-June/032841.html)
- **Scaling Factor**: 1×, 2×, 3×, or 4× applied through analog circuits

#### Character Scaling and Optimization
- **Size Control**: Small/medium/large scaling applied through analog circuits [³](https://classiccmp.org/pipermail/cctech/2018-June/032841.html)
- **Stroke Optimization**: Minimize total stroke count for refresh rate, optimize stroke order to reduce blanked moves, consider beam settling time between strokes
- **Analog Effects on Stroke Patterns**: Corner rounding from bandwidth limitations, brightness variations from velocity changes, character distortion from signal path filtering

### System Performance
- **Refresh Rate**: Variable depending on number of vectors displayed (50Hz considered high) [¹](https://retrocomputing.stackexchange.com/questions/17115/cdc-6600-system-console)
- **Bandwidth Limitations**: Signal chain has barely sufficient bandwidth for character drawing [³](https://classiccmp.org/pipermail/cctech/2018-June/032841.html)
- **Power Supply Noise**: 400Hz jitter (to be confirmed) [User observation]

### Deflection System Filter Characteristics (Estimated)
Based on analysis of timing specifications and screenshot artifacts:

#### Low-Pass Filter Parameters (Revised)
- **-3dB Bandwidth**: 600-800 kHz (corrected for 4× character scaling)
- **Filter Order**: 2nd order system (12 dB/octave rolloff)
- **Damping Ratio (ζ)**: 0.7-0.8 (slightly underdamped)
- **Natural Frequency (ωn)**: ~5 × 10⁶ rad/s (800 kHz)
- **Rise Time (10-90%)**: ~100-125ns (comparable to 100ns stroke segment)
- **Settling Time**: 200-300ns (2-3 stroke segments)
- **Overshoot**: 5-8% (observed as brightness peaks at stroke ends)

#### Evidence from Vector Step Timing (Corrected for Scale)
- **100ns stroke segments**: System rise time comparable to segment period
- **Maximum slew**: 8 units/100ns at 4× scale = 2 base units/100ns (0.39% of 512 full scale)
- **Corner rounding**: 3-4 units of 32-unit character (10-12%) indicates 100-125ns rise time
- **Brightness variations**: Visible at corners where beam dwells for ~2 stroke segments
- **Scale context**: Screenshot shows 4× scaled characters on 32×32 grid portion of 512×512 total

#### Transfer Function Estimate (Revised)
Approximated as 2nd order low-pass:
```
H(s) = ωn²/(s² + 2ζωn·s + ωn²)
Where: ωn ≈ 5×10⁶ rad/s (800 kHz), ζ ≈ 0.75
```

This creates the characteristic "whimsical handwritten" appearance through:
- Rounded corners from limited slew rate
- S-curve distortion in diagonal strokes
- Velocity-dependent brightness variations
- Slight overshoot at direction changes

### Implementation Notes for Filter Emulation

#### Digital Filter Design Considerations
- **Sample Rate**: Minimum 10 MHz (10× highest frequency) for accurate filter modeling
- **Filter Type**: IIR Butterworth or custom 2nd order for efficiency
- **Bilinear Transform**: Use pre-warping at fc = 500 kHz to maintain cutoff accuracy
- **State Variables**: Maintain separate X and Y channel states (may have slight differences)

#### Critical Implementation Details
**Input/Output Scaling:**
- Input: 9-bit DAC values (0-511)
- Output: Normalized deflection (-1.0 to +1.0) for display coordinates
- Consider DAC non-linearity: ±0.5 LSB typical for 1960s converters

**Step Response Characteristics to Emulate (Revised for Scale):**
- 10% to 90% rise: 100-125ns
- 5% settling: 200-300ns  
- Peak overshoot: 5-8% at t ≈ 130ns
- Damped oscillation frequency: ~1.5 MHz (visible in overshoot)

**Brightness Modulation from Beam Velocity:**
```
brightness = base_intensity / (1 + k * |dV/dt|)
Where:
- k ≈ 0.3-0.5 (empirically adjusted)
- |dV/dt| = magnitude of deflection velocity vector
- Clamp minimum brightness to ~0.4 of base
```

**Asymmetry Considerations:**
- X and Y channels may have different ωn (±10% variation)
- Rise time may differ from fall time (tube amplifier asymmetry)
- Consider modeling 3CX100A5 tube saturation at extreme deflections

**Noise and Jitter:**
- Add 400 Hz sinusoidal component (±0.2% of full scale)
- Include white noise: ~0.1% RMS of signal amplitude
- Phase noise on 400 Hz: ±5 degrees variation

#### Discrete-Time Implementation (Z-domain)
For real-time emulation at sample rate Fs:
```
Tustin approximation with pre-warping:
ω'n = (2/T) * tan(ωn*T/2)  where T = 1/Fs

Difference equation form:
y[n] = b0*x[n] + b1*x[n-1] + b2*x[n-2] - a1*y[n-1] - a2*y[n-2]

Coefficients for Fs = 10 MHz, fc = 500 kHz, ζ = 0.65:
(To be calculated during implementation)
```

#### Phosphor Interaction with Beam Velocity
- Phosphor excitation inversely proportional to beam velocity
- Implement phosphor "charging" model: slower movement = more energy deposited
- P31 decay: exponential with τ ≈ 1ms for 90% decay
- Consider beam spot size variation with velocity (focus effects)

#### Edge Cases and Limits
- Slew rate limiting: Maximum 80 units/μs (before filter)
- Amplifier saturation: Soft clipping at ±450 units (of 512 nominal)
- Minimum settling time between vectors: 500ns for full-scale step
- Beam blanking during large jumps: >100 units may trigger blanking

#### Validation Metrics
Compare emulated vs. observed characteristics:
1. Corner radius: Should be 10-15% of character height
2. Diagonal S-curve amplitude: ~2-3% of stroke length
3. Brightness ratio (corner:straight): ~1.5:1 to 2:1
4. Overshoot visibility: Just perceptible as brightness increase

#### Future Refinements
- Temperature drift modeling (component aging)
- Power supply ripple correlation with mainframe load
- Magnetic field interference (Earth's field, nearby equipment)
- Phosphor burn-in effects for frequently drawn patterns
- Beam defocus at high velocities (electron optics)

## Observed Display Characteristics

### Empirical Observations from Video Analysis
Based on analysis of DD60 display screenshot from [CDC console video](https://www.youtube.com/watch?v=wcSmUEaCRp8):

**Screenshot Context**: Image shows quadruple-height characters drawn on 32×32 unit grid (4× scaling of base 8×8 character grid). File: `dd60_close_up_display_screenshot_numeric_characters.png`

### Standalone Image Analysis Observations

#### Brightness Distribution Patterns
- **Stroke Start/End Intensity**: Visibly brighter at stroke initiation and termination points (approximately 1.5-2× mid-stroke brightness)
- **Corner Brightness Accumulation**: Corners show 2-3× brightness of straight segments due to beam dwelling
- **Mid-Stroke Dimming**: Center portions of long strokes (e.g., top of "5") are consistently dimmer
- **Intersection Hot Spots**: Where strokes cross (e.g., center of "8"), brightness peaks significantly
- **Non-Uniform Brightness**: Significant brightness variation along stroke paths, brighter at stroke beginnings/ends

#### Geometric Distortion Measurements
- **Corner Rounding Radius**: 3-4 units on 32-unit character height (10-12% of character height)
- **Diagonal S-Curve Amplitude**: Approximately 1 unit deflection (3% of stroke length) visible in "7" diagonals
- **Overshoot at Stroke Ends**: 5-8% past intended endpoint, visible as brightness spike
- **Character Height Variation**: Same digits vary by ±1 unit (±3%) between instances

#### Phosphor and Beam Effects
- **Bloom Radius**: Green glow extends 2-3 units beyond stroke edges (6-9% of character width)
- **Halation Pattern**: Asymmetric, stronger on right/bottom edges suggesting beam approach direction
- **Ghost Trail Length**: Faint persistence trail extends 1-2 units behind fast movements
- **Beam Focus Variation**: Stroke width varies from ~1.5 units (focused) to ~2.5 units (defocused at high velocity)
- **Phosphor Bloom**: Green phosphor glow extends beyond stroke boundaries with halation effects
- **Phosphor Persistence Effects**: Slight trailing/ghosting visible on stroke edges consistent with P31 phosphor

#### Velocity-Dependent Characteristics
- **Brightness vs. Speed Correlation**: Fast diagonal strokes ~40% dimmer than slow curves
- **Focus Degradation**: High-velocity segments show 50% width increase
- **Settling Oscillation**: Visible as 2-3 diminishing brightness peaks after abrupt stops

#### Analog System Artifacts
- **Inter-Character Variation**: Identical digits ("7" instances) show different curvature patterns
- **Baseline Drift**: Characters appear to have slight vertical offset variations (±0.5 units)
- **Noise Texture**: Fine-grain brightness variations visible in phosphor glow
- **Asymmetric Rise/Fall**: Left edges sharper than right edges on horizontal strokes
- **Stroke Curvature**: Straight strokes show noticeable curvature and S-curves in diagonal lines
- **Beam Settling Artifacts**: Corner transitions show overshoots and rounded corners instead of sharp angles
- **Character Inconsistency**: Same digits display slightly different shapes due to analog variations

### Known Distortion Causes
- **Character Distortion**: Limited bandwidth causes on-screen shapes to differ from nominal patterns [³](https://classiccmp.org/pipermail/cctech/2018-June/032841.html)
- **Analog Circuit Response**: Distorted angular stroke patterns, giving characters distinctive handwritten look [²](https://www.mail-archive.com/cctalk@classiccmp.org/msg36279.html)

## Modern Emulation Considerations

### Implementation Priorities

#### Essential Techniques
- Beam velocity-dependent brightness modulation
- Phosphor persistence modeling with accurate decay curves
- Gamma-correct processing throughout rendering pipeline
- Variable MPRT (Motion Picture Response Time) for different brightness levels
- High refresh rate display targeting (240Hz+ for best results)

#### Vector-Specific Requirements
- Arbitrary angle line drawing vs raster scanning
- Beam settling time between vector segments
- Variable drawing speeds affecting brightness
- Long-persistence phosphor simulation for complex patterns
- Direct beam positioning rather than scanline-based rendering
- Display jitter from power supply noise (TBC 400Hz)

#### Implementation Challenges
- Need to balance performance vs accuracy
- Artifacts (flickering, banding) require careful tuning
- Resolution requirements for accurate phosphor mask simulation
- Platform-specific performance variations
- Real-time constraints vs computational complexity

### Key Implementation Takeaways

Based on analysis of modern CRT emulation research, critical considerations for DD60 emulation include:

**Critical Gotchas:**
- Need to balance performance vs accuracy
- Artifacts (flickering, banding) require careful tuning
- Resolution requirements for accurate phosphor mask simulation
- Platform-specific performance variations
- Real-time constraints vs computational complexity

### Future Implementation Notes
*[This section will document how the research translates to implementation decisions]*

## Research References

### Primary Documentation
* [CDC 6600 Diagrams and Circuit Description](http://www.bitsavers.org/pdf/cdc/cyber/cyber_70/fieldEngr/60125000C_6602_6603_6622_6681_6682_Data_Channel_Diagrams_Dec65.pdf) - See pages 26 to 30 for character forms
* [Design of a Computer: The Control Data 6600](http://ygdes.com/CDC/DesignOfAComputer_CDC6600.pdf) - J.E. Thornton

### Visual References
* [Video of CDC console](https://www.youtube.com/watch?v=wcSmUEaCRp8) - Source for screenshot analysis

### Community Resources
* [Retro1.org](https://codex.retro1.org/cdc:start) - Everything CDC
* [Retro 1 mail archive](https://archer.retro1.org/login)

### Technical Background
* [Cathode Ray Tubes: Getting Down To Basics](https://w140.com/tekwiki/images/2/2b/068-0313-00.pdf)

### Modern CRT Emulation Research
* [BlurBusters CRT Beam Simulator](https://github.com/blurbusters/crt-beam-simulator) - Real-time electron beam simulation shader
* [CRT Simulation in a GPU Shader](https://blurbusters.com/crt-simulation-in-a-gpu-shader-looks-better-than-bfi/) - Breakthrough algorithm
* [Vector Display Simulation](https://github.com/negativefnnancy/CRT-Vector-Display-Simulation) - Electron beam phosphor interaction
* [CRT Shaders Overview](https://emulation.gametechwiki.com/index.php/CRT_shaders) - Comprehensive guide to techniques
* [Simulating CRT Monitors with FFmpeg](https://int10h.org/blog/2021/01/simulating-crt-monitors-ffmpeg-pt-1-color/) - Software approaches
* [RetroTINK CRT Beam Emulation](https://www.retrorgb.com/retrotink-4k-pro-crt-beam-emulation.html) - Hardware-based emulation
* [Hackaday: Vector Display Simulation](https://hackaday.com/2012/12/10/simulating-crt-or-vector-displays-for-more-realistic-emulation/)

### Citation References
[¹] Retrocomputing Stack Exchange - CDC 6600 System Console Discussion  
[²] CCTalk Mailing List Archives - CDC 6600 Display Character Generation  
[³] ClassicCmp.org Archives - CDC 6600 Technical Details  
[⁴] PubMed - P31 Phosphor Persistence Research  
[⁵] LabGuy's World - Electrostatic CRT Deflection Documentation  
[⁶] Wikipedia - CDC 6600  
[⁷] Computer History Museum - J.E. Thornton Collection  

## Appendix: Modern CRT Emulation Analysis

### Relevance Ranking for DD60 Project

1. **Vector Display Simulation (negativefnnancy)** - Most directly relevant as it specifically targets vector CRT physics
2. **BlurBusters CRT Beam Simulator** - Excellent for understanding real-time beam simulation techniques applicable to vectors
3. **CRT Simulation GPU Shader Article** - Important for brightness redistribution and phosphor modeling algorithms
4. **CRT Shaders Overview** - Valuable for understanding phosphor masks and beam characteristics
5. **FFmpeg CRT Simulation** - Good reference for gamma-correct processing pipeline
6. **Hackaday Vector Display Article** - Limited but some useful insights on phosphor rendering complexity
7. **RetroTINK Hardware CRT Emulation** - Least relevant as hardware-specific, but rolling scan concepts useful

### Detailed Analysis of Modern Approaches

#### 1. BlurBusters CRT Beam Simulator
**Key Observations:**
- Real-time electron beam simulation using GPU shaders (GLSL/HLSL)
- Achieves ~75% motion blur reduction at 240Hz displays
- Works best on OLED displays, less effective with local dimming

**Techniques:**
- Temporal simulation with rolling scan
- Variable per-pixel MPRT (Motion Picture Response Time)
- Brightness redistribution algorithm to maintain image brightness

**Gotchas:**
- Potential flickering, banding, and color ghosting artifacts
- Performance varies significantly across platforms
- Requires high refresh rate displays (240Hz+ optimal)

#### 2. CRT Simulation GPU Shader Article
**Key Observations:**
- Breakthrough algorithm by Mark Rejhon and Timothy Lottes
- Superior to traditional Black Frame Insertion (BFI)
- Reduces eyestrain compared to conventional methods

**Techniques:**
- Brightness redistribution: compresses MPRT for average pixels, extends for bright pixels
- Soft phosphor fade simulation
- Configurable gain values for motion blur/brightness tradeoff

**Gotchas:**
- Requires high-performance GPUs
- Best results need 240Hz+ displays, especially OLEDs
- Recommended to use SDR mode for display configuration

#### 3. Vector Display Simulation (negativefnnancy)
**Key Observations:**
- Written in ANSI C using SDL2
- Physics-based simulation of electron beam/phosphor interaction
- Focuses on vector-specific display physics

**Techniques:**
- Direct electron beam manipulation modeling
- Phosphor interaction physics

**Gotchas:**
- Project in early stages, lacks comprehensive documentation
- No detailed implementation specifics available

#### 4. CRT Shaders Overview (GameTechWiki)
**Key Observations:**
- Multiple phosphor mask types: aperture grille, slot mask, dot mask
- Resolution requirements vary by mask type
- Complex beam characteristic simulations

**Techniques:**
- Variable beam width simulation (brighter pixels bleed more)
- Beam convergence offset modeling
- Scanline blooming with TVL density simulation
- Gamma-aware processing throughout pipeline

**Gotchas:**
- Requires 2560x1440 minimum for slot mask, 4K recommended
- 1080p only suitable for aperture grille emulation
- Extremely high resolution needed for accurate dot mask representation

#### 5. FFmpeg CRT Simulation
**Key Observations:**
- Software-based approach focusing on accuracy
- Uses PNG overlays for phosphor masks
- Emphasizes gamma-correct processing

**Techniques:**
- Multi-stage pipeline: scaling, blur, halation, scanlines, curvature
- Configurable phosphor mask overlay with scaling/opacity
- Anti-moiré techniques for curvature correction

**Gotchas:**
- Extremely CPU-intensive (10GB RAM usage possible)
- Requires 64-bit FFmpeg
- Too slow for real-time processing

#### 6. RetroTINK Hardware CRT Emulation
**Key Observations:**
- Hardware-based solution using rolling BFI
- Achieves ~75% motion blur reduction for 60Hz sources
- Experimental technique

**Techniques:**
- Rolling scan BFI implementation
- Configurable beam steepness (3-5 recommended)
- Phosphor glow adjustment (6 at 240Hz)

**Gotchas:**
- Only viable on RetroTINK 4K Pro
- Requires 1080p240Hz or 1080p120Hz display
- Not supported on newer/cheaper hardware

#### 7. Hackaday Vector Display Article
**Key Observations:**
- Limited vector-specific details
- Emphasizes complexity of phosphor rendering

**Techniques:**
- Sub-pixel detail rendering (32x32 bitmap for phosphor dots)
- Signal processing considerations

**Gotchas:**
- Article lacks comprehensive vector-specific implementation details
- More focused on raster CRT discussion